#!/usr/bin/env python

import argparse
import cps
import os
import sys

from cps import iterate, get_extension

block_header = """
# Generated by cps2cmake
# https://github.com/mwoehlke/pycps

if(CMAKE_MAJOR_VERSION LESS 3)
  message(FATAL_ERROR "CMake >= 3.0 required")
endif()
cmake_policy(PUSH)
cmake_policy(VERSION 3.0)
set(CMAKE_IMPORT_FILE_VERSION 1)

if(CMAKE_VERSION VERSION_LESS 3.9.0)
  # Imported from CMake 3.9.0
  macro(find_dependency dep)
    if (NOT ${dep}_FOUND)
      set(cmake_fd_quiet_arg)
      if(${CMAKE_FIND_PACKAGE_NAME}_FIND_QUIETLY)
        set(cmake_fd_quiet_arg QUIET)
      endif()
      set(cmake_fd_required_arg)
      if(${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED)
        set(cmake_fd_required_arg REQUIRED)
      endif()

      get_property(cmake_fd_alreadyTransitive GLOBAL PROPERTY
        _CMAKE_${dep}_TRANSITIVE_DEPENDENCY
      )

      find_package(${dep} ${ARGN}
        ${cmake_fd_quiet_arg}
        ${cmake_fd_required_arg}
      )

      if(NOT DEFINED cmake_fd_alreadyTransitive OR cmake_fd_alreadyTransitive)
        set_property(GLOBAL PROPERTY _CMAKE_${dep}_TRANSITIVE_DEPENDENCY TRUE)
      endif()

      if (NOT ${dep}_FOUND)
        set(${CMAKE_FIND_PACKAGE_NAME}_NOT_FOUND_MESSAGE "${CMAKE_FIND_PACKAGE_NAME} could not be found because dependency ${dep} could not be found.")
        set(${CMAKE_FIND_PACKAGE_NAME}_FOUND False)
        return()
      endif()
      set(cmake_fd_required_arg)
      set(cmake_fd_quiet_arg)
      set(cmake_fd_exact_arg)
    endif()
  endmacro()
else()
  include(CMakeFindDependencyMacro)
endif()
"""

block_check_targets = """
set(_targetsDefined)
set(_targetsNotDefined)

foreach(_expectedTarget ${_expectedTargets})
  if(NOT TARGET ${_expectedTarget})
    list(APPEND _targetsNotDefined ${_expectedTarget})
  endif()
  if(TARGET ${_expectedTarget})
    list(APPEND _targetsDefined ${_expectedTarget})
  endif()
endforeach()
if("${_targetsDefined}" STREQUAL "${_expectedTargets}")
  set(CMAKE_IMPORT_FILE_VERSION)
  cmake_policy(POP)
  return()
endif()
if(NOT "${_targetsDefined}" STREQUAL "")
  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\\nTargets Defined: ${_targetsDefined}\\nTargets not yet defined: ${_targetsNotDefined}\\n")
endif()
unset(_targetsDefined)
unset(_targetsNotDefined)
unset(_expectedTargets)
"""

block_get_prefix = """
get_filename_component(${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX "${${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX}" PATH)
get_filename_component(${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX "${${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX}" PATH)
get_filename_component(${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX "${${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX}" PATH)

if(${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX STREQUAL "/")
  set(${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX)
endif()
"""

block_footer = """
unset(${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX)
unset(CMAKE_IMPORT_FILE_VERSION)
cmake_policy(POP)
"""

block_check_version = """
if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
  set(PACKAGE_VERSION_COMPATIBLE FALSE)
elseif(PACKAGE_VERSION VERSION_LESS COMPAT_VERSION)
  set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
  set(PACKAGE_VERSION_COMPATIBLE TRUE)
  if(PACKAGE_VERSION STREQUAL PACKAGE_FIND_VERSION)
    set(PACKAGE_VERSION_EXACT TRUE)
  endif()
endif()

unset(PACKAGE_COMPAT_VERSION)
"""

library_types = {
    'dylib': 'SHARED',
    'archive': 'STATIC',
    'module': 'MODULE',
    'interface': 'INTERFACE'
}

cpp11_features = {'cxx_decltype'}
cpp14_features = {'cxx_decltype_auto'}.union(cpp11_features)
cpp17_features = {'cxx_std_17'}
cpp20_features = {'cxx_std_20'}
feature_map = {
    'c++11': cpp11_features,
    'c++14': cpp14_features,
    'c++17': cpp17_features,
    'c++20': cpp20_features,
}

#------------------------------------------------------------------------------
def cmake_qualified_component_name(package, component_name):
    return '::'.join((package.name, component_name))

#------------------------------------------------------------------------------
def cmake_qualified_component_names(package):
    fixup = lambda c: cmake_qualified_component_name(package, c)
    return map(fixup, package.components)

#------------------------------------------------------------------------------
def fixup_path(path):
    if path.startswith('@prefix@'):
        return '${${CMAKE_FIND_PACKAGE_NAME}_IMPORT_PREFIX}' + path[8:]

    return path

#------------------------------------------------------------------------------
def canonical_component_name(component, package):
    if component.startswith(':'):
        return ':'.join((package.name, component[1:]))

    return component

#------------------------------------------------------------------------------
def cmake_canonical_component_name(package, component):
    if ':' not in component:
        return '${%s_LIBRARIES}' % component

    component = canonical_component_name(component, package)
    return '::'.join(component.split('@')[0].split(':'))

#------------------------------------------------------------------------------
def link_dependencies(package, component):
    def fixup(dep):
        return cmake_canonical_component_name(package, dep)

    deps = list(map(fixup, component.requires))

    link_only_deps = map(fixup, component.link_requires)
    deps += map(lambda d: '$<LINK_ONLY:%s>' % d, link_only_deps)

    deps += component.link_flags[None]

    return deps

#------------------------------------------------------------------------------
def print_target_rules(package, component_name, component):
    # TODO java targets
    kind = component.kind.lower()
    if kind in library_types:
        print('add_library(%s %s IMPORTED)' %
              (component_name, library_types[kind]))
        print('set_target_properties(%s PROPERTIES' % component_name)

        if component.link_location is not None:
            print('  IMPORTED_LOCATION "%s"' %
                  fixup_path(component.link_location))
            if kind == 'dylib':
                soname = os.path.basename(component.link_location)
                if sys.platform == 'darwin':
                    soname = os.path.join('@rpath', soname)
                print('  IMPORTED_SONAME "%s"' % soname)

        includes = component.includes[None]
        if len(includes):
            includes = map(fixup_path, includes)
            print('  INTERFACE_INCLUDE_DIRECTORIES "%s"' % ';'.join(includes))

        link_deps = link_dependencies(package, component)
        if len(link_deps):
            print('  INTERFACE_LINK_LIBRARIES "%s"' % ';'.join(link_deps))

        features = set()
        for feature in component.compile_features:
            features = features.union(feature_map.get(feature, set()))
        if len(features):
            print('  INTERFACE_COMPILE_FEATURES "%s"' % ';'.join(features))

        definitions = component.definitions[None]
        definitions = [d for d in definitions if not d.startswith('!')]
        if len(definitions):
            print('  INTERFACE_COMPILE_DEFINITIONS "%s"' %
                  ';'.join(definitions))

        cflags = component.compile_flags[None]
        if len(cflags):
            print('  INTERFACE_COMPILE_OPTIONS "%s"' % ';'.join(cflags))

        print(')')

    elif kind == 'exe':
        print('add_executable(%s IMPORTED)' % component_name)
        print('set_target_properties(%s PROPERTIES' % component_name)
        print('  IMPORTED_LOCATION "%s"' % fixup_path(component.location))
        print(')')

    elif kind == 'jar':
        print('add_library(%s STATIC IMPORTED)' % component_name)
        print('set_target_properties(%s PROPERTIES' % component_name)
        print('  IMPORTED_LOCATION "%s"' % fixup_path(component.location))
        print('  JAR_FILE "%s"' % fixup_path(component.location))
        print(')')

#------------------------------------------------------------------------------
def print_convenience_rules(package):
    fixup = lambda c: cmake_canonical_component_name(package, c)
    libs = map(fixup, package.default_components)
    print('set(%s_LIBRARIES "%s")' % (package.name, ';'.join(libs)))
    print('set(%s_INCLUDE_DIRS "")' % package.name)
    print('')

#------------------------------------------------------------------------------
def print_cmake_extensions(package, ext_template='X-CMake-{}'):
    incvar = ext_template.format('Includes')
    for item in get_extension(package, incvar, []):
        print('include(%s)' % item)

    varvar = ext_template.format('Variables')
    for item in iterate(get_extension(package, varvar, {})):
        print('set(%s "%s")' % item)

#------------------------------------------------------------------------------
def print_targets_config(package):
    print(block_header)
    print(block_get_prefix) # TODO account for install subdirectory

    print_cmake_extensions(package, 'X-CMake-{}-Init')

    for requirement_name, requirement_info in iterate(package.requires):
        fd_args = ''
        if requirement_info.version is not None:
            fd_args += ' ' + requirement_info.version
        for item in get_extension(requirement_info, 'X-CMake-Find-Args', []):
            fd_args += ' ' + item
        if len(requirement_info.components):
            fd_args += ' COMPONENTS ' + ' '.join(requirement_info.components)
        if len(requirement_info.hints):
            hints = [fixup_path(p) for p in requirement_info.hints]
            fd_args += ' HINTS "' + '" "'.join(hints) + '"'

        print('find_dependency(%s%s)' % (requirement_name, fd_args))

    targets = cmake_qualified_component_names(package)
    print('set(_expectedTargets %s)' % ' '.join(targets))
    print(block_check_targets)

    if package.version is not None:
        print('set(%s_VERSION "%s")' % (package.name, package.version))
        print('')

    for component_name, component in iterate(package.components):
        component_name = cmake_qualified_component_name(package, component_name)
        print_target_rules(package, component_name, component)
        print('')

    print_convenience_rules(package)
    print_cmake_extensions(package)

    print(block_footer)

#------------------------------------------------------------------------------
def print_version_check(package):
    if package.version is not None:
        print('set(PACKAGE_VERSION "%s")' % package.version)
        print('set(PACKAGE_COMPAT_VERSION "%s")' % package.compat_version)
        print(block_check_version)

    # TODO arch check (32-bit vs. 64-bit)

#------------------------------------------------------------------------------
def main(args):
    parser = argparse.ArgumentParser()
    parser.add_argument('input', metavar='CPS_FILE', type=str,
                        help='Input CPS file')
    parser.add_argument('--version-check',
                        dest='version_check', action='store_true',
                        help='Emit version check instead of targets')
    args = parser.parse_args(args)

    package = cps.read(args.input, canonicalize=False)

    if args.version_check:
        print_version_check(package)
    else:
        print_targets_config(package)

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if __name__ == "__main__":
    main(sys.argv[1:])
